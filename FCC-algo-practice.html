<!DOCTYPE html>
<html>
<head>
	<title>FCC Algo Practice</title>
</head>
<body>
	<h1>FCC Algo Practice</h1>
	
	<script>
	

//-----------------------------------------------------------------------------------------------------------------------------------


// =============  Quick Sort  ======================

// Here we will move on to an intermediate sorting algorithm: quick sort. Quick sort is an efficient, recursive divide-and-conquer approach to sorting an array. In this method, a pivot value is chosen in the original array. The array is then partitioned into two subarrays of values less than and greater than the pivot value. We then combine the result of recursively calling the quick sort algorithm on both sub-arrays. This continues until the base case of an empty or single-item array is reached, which we return. The unwinding of the recursive calls return us the sorted array.

// Quick sort is a very efficient sorting method, providing O(nlog(n)) performance on average. It is also relatively easy to implement. These attributes make it a popular and useful sorting method.

// Instructions: Write a function quickSort which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest. While the choice of the pivot value is important, any pivot will do for our purposes here. For simplicity, the first or last element could be used.

/*

function quickSort(arr) {

	if (arr.length <= 1) {  // if we reach [x] or [], we simply return the same array
		return arr;
	}

	let pivot = arr.pop();  // making last element of the array as pivot, also popped from the array at the same time

	let leftArr = arr.filter(elem => elem <= pivot);  // all items in remaining array <= pivot 
	let rightArr = arr.filter(elem => elem > pivot);

	return quickSort(leftArr).concat([pivot]).concat(quickSort(rightArr));

}	



console.log(quickSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));
// console.log(quickSort([2, 3]));

*/

//===============================================================================================================================================================================

// ============= INSERTION SORT ===================

// The next sorting method we'll look at is insertion sort. This method works by building up a sorted array at the beginning of the list. It begins the sorted array with the first element. Then it inspects the next element and swaps it backwards into the sorted array until it is in sorted position. It continues iterating through the list and swapping new items backwards into the sorted portion until it reaches the end. This algorithm has quadratic time complexity in the average and worst cases.

// Instructions: Write a function insertionSort which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest.

/*


function insertionSort(arr) {
	// debugger;

	return arr.reduce( (acc, x, i) => {
		if (acc.length === 0) {
			acc.push(x);
			return acc;
		}

		for(let i = acc.length - 1; i >= 0; i--) {
			if(acc[i] <= x) {
				// insert x
				acc.splice(i + 1, 0, x);
				return acc;
			}
		}

	}, []);

}


console.log(insertionSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));


*/


//=========================================================================================================================================================================


// =============  SELECTION SORT ===================


// Here we will implement selection sort. Selection sort works by selecting the minimum value in a list and swapping it with the first value in the list. It then starts at the second position, selects the smallest value in the remaining list, and swaps it with the second element. It continues iterating through the list and swapping elements until it reaches the end of the list. Now the list is sorted. Selection sort has quadratic time complexity in all cases.

// Instructions: Write a function selectionSort which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest.

/*

function selectionSort(arr) {
	let copy = arr.slice();

	// debugger;

	for(let i = 0, length = arr.length; i < length; i++) {
		let incl = copy.slice(0, i + 1);  // sliced upto and including the 'ith' element
		let rem = copy.slice(i + 1);  //sliced after the 'ith' element
		let [min, index] = findMinWithIndex(rem); // returns an array [minimum, index of minimum]

		if (min < copy[i]) {
			[incl[incl.length - 1], rem[index]] = [rem[index], incl[incl.length - 1]];  // swap the last elem of incl with the min of rem
			copy = incl.concat(rem);  // combine the incl and rem to form the copy array again
		}
		
	}

	return copy;

	function findMinWithIndex(arr) {
		let min = Math.min(...arr);
		let index = arr.indexOf(min);
		return [min, index];
	}
}


console.log(selectionSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));


*/


// =======================================================================================================================================================================



//  ========  BUBBLE SORT  ==========

// Here we will see bubble sort. The bubble sort method starts at the beginning of an unsorted array and 'bubbles up' unsorted values towards the end, iterating through the array until it is completely sorted. It does this by comparing adjacent items and swapping them if they are out of order. The method continues looping through the array until no swaps occur at which point the array is sorted.

// This method requires multiple iterations through the array and for average and worst cases has quadratic time complexity. While simple, it is usually impractical in most situations.

// Instructions: Write a function bubbleSort which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest

/*

function bubbleSort(arr) {
	let swaps; // a global flag that keeps track if any swaps occured during a pass	

	// debugger;

	do {

		swaps = false;
		arr = arr.reduce( (acc, x) => {  // each 'reduce' cycle is a 'pass' through the array, sorting as it finds 

			let lastElement = acc[acc.length - 1];

			if (lastElement && lastElement > x) {
				swaps = true;
				[acc[acc.length - 1], x] = [x, acc[acc.length - 1]];
				acc.push(x);

			} else {
				acc.push(x)
			}

			return acc;

		}, []);

	} while (swaps);

	return arr;

}


console.log(bubbleSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));


*/

//  ==================== PAIRWISE ==============================

/*

Given an array arr, find element pairs whose sum equal the second argument arg and return the sum of their indices.

You may use multiple pairs that have the same numeric elements but different indices. Each pair should use the lowest possible available indices. Once an element has been used it cannot be reused to pair with another element. For instance, pairwise([1, 1, 2], 3) creates a pair [2, 1] using the 1 at indice 0 rather than the 1 at indice 1, because 0+2 < 1+2.

For example pairwise([7, 9, 11, 13, 15], 20) returns 6. The pairs that sum to 20 are [7, 13] and [9, 11]. We can then write out the array with their indices and values.

Index	0	1	2	3	4
Value	7	9	11	13	15
Below we'll take their corresponding indices and add them.

7 + 13 = 20 → Indices 0 + 3 = 3
9 + 11 = 20 → Indices 1 + 2 = 3
3 + 3 = 6 → Return 6

*/

/*

function pairwise(arr, arg) {

	// debugger;

	let answer = 0;

	// To remember the original indices of the input array, we map the array to an array of objects {index: x, value: y}
	let temp = arr.map((elem, i) => ( {index: i, value: elem} ));

	// debugger;

	first:while(temp.length > 1) {
		for(let i = 0; i < temp.length; i++) {
			for(let j = i + 1; j < temp.length; j++) {

				if(temp[i].value + temp[j].value === arg ) {  // if the sum of two numbers is equal to arg

					answer += temp[i].index + temp[j].index;
					temp = removeTwoElements(temp, i, j);
					continue first;  // we modify the temp and go back to the while loop with new temp array of objects					
				}
			}
		}
		break;  // if no obj matches the condition, we exit the while loop
	}

	return answer;

	// HELPER FUNCION
	function removeTwoElements(arr, ind1, ind2) {  // returns an array (without modifing input) with 2 elements at given indices removed
		return arr.filter((elem, i) => i !== ind1 && i !== ind2);
	}
}




console.log(pairwise([1, 1, 2], 3));  //return 2
console.log(pairwise([1, 4, 2, 3, 0, 5], 7))// should return 11.
console.log(pairwise([1, 3, 2, 4], 4))// should return 1.
console.log(pairwise([1, 1, 1], 2))// should return 1.
console.log(pairwise([0, 0, 0, 0, 1, 1], 1))// should return 10.
console.log(pairwise([], 100))// should return 0.

*/

//========================================================================================================================================================


// - No Repeats Please ***

// Return the number of total permutations of the provided string that don't have repeated consecutive letters. Assume that all characters in the provided string are each unique.

// For example, aab should return 2 because it has 6 total permutations (aab, aab, aba, aba, baa, baa), but only 2 of them (aba and aba) don't have the same letter (in this case a) repeating.

/*

function permAlone(str) {  // for example 'abc'
  
	// We start by calculating the total number of permutations of the input string, this is achieved by the permuations function defined below	


	let perms = permutations(str);


	perms = perms.filter( (str, i) => {
		for(let i = 0; i < str.length; i++) {
			if(str[i] === str[i + 1]) {
				return false
			}
		}
		return true;
	})  

	return perms.length;
 

	 function permutations(str) {  // this function takes a string and returns an array of all permutations

	 	// This function was not written by me, this is copied from a comment on StackOverFlow, the function uses recursion to calculate all the permutations
		// Better and faster algo's exist to calculate all permuations, however, below is the easier es6 version

	 	let inputArray = [...str];
	 	let result = [];

	 	function permute(arr, m = []) {
	 	  if (arr.length === 0) {
	 	  	result.push(m);
	 	  }	else {
	 	  	for (let i = 0; i < arr.length; i++) {
	 	  		let curr = arr.slice();
	 	  		let next = curr.splice(i, 1);  // This changes curr and next at once, ith element of curr is put as next and removed from curr
	 	  		permute(curr.slice(), m.concat(next))
	 	  	}
	 	  }
	 	}

	 	// This is how the permute function works

	 	// for an input arr of ['a', 'b', 'c']

	 	// permute([a, b, c])

	 		// permute([b, c], [a])

	 			// permute([c], [a, b])

	 				// permute([], [a, b, c]) 

	 					// returns [a, b, c]; result([ [a, b, c] ])

		 		// permute([b], [a, c])

		 			// permute([], [a, c, b])

		 				// return [a, c, b]; result = [ [a, b, c], [a, c, b]]


			// permute([a, c], [b])

			 	// permute([c], [b, a])

			 		// permute([], [b, a, c])

			 		  // return [b, a, c]; result = [ [abc], [acb], [bac]]

			 	// permute([a], [b, c])

			 		// permute([], [b, c, a])

			 			// return [b, c, a]; result = [ [abc], [acb], [bac], [bca] ]





	 	permute(inputArray);
	 	return result.map(arr => arr.join(''));
	 }

}


console.log(permAlone('aab'))

*/

// console.log(permAlone('aab'));
// console.log(permAlone("aabb")); //should return 8
// console.log(permAlone("abcdefa"))// should return 3600.

//============================================================================================================================================

/*

// - INVENTORY UPDATE

// Compare and update the inventory stored in a 2D array against a second 2D array of a fresh delivery. Update the current existing inventory item quantities (in arr1). If an item cannot be found, add the new item and quantity into the inventory array. The returned inventory array should be in alphabetical order by item.



function updateInventory(arr1, arr2) {
    // All inventory must be accounted for or you're fired!

    let inventoryCount = arr1.length;

    // debugger;
    start: for(let item of arr2) {
    	for(let i = 0; i < inventoryCount; i++) {
    		if(arr1[i][1] === item[1]) {
    			arr1[i][0] += item[0];
    			continue start; // if the search is successful, we return to the next element
    		}
    	}
    	arr1.push(item);
    }

    return arr1.sort((a, b) => {
    	return a[1] < b[1] ? -1: a[1] === b[1] ? 0: 1;
    });
}

// // Example inventory lists
// var curInv = [
//     [21, "Bowling Ball"],
//     [2, "Dirty Sock"],
//     [1, "Hair Pin"],
//     [5, "Microphone"]
// ];

// var newInv = [
//     [2, "Hair Pin"],
//     [3, "Half-Eaten Apple"],
//     [67, "Bowling Ball"],
//     [7, "Toothpaste"]
// ];

console.log(updateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]])); 

//should return [[88, "Bowling Ball"], [2, "Dirty Sock"], [3, "Hair Pin"], [3, "Half-Eaten Apple"], [5, "Microphone"], [7, "Toothpaste"]]);

console.log(updateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [])) // should return [[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]].


*/

//===============================================================================================

/*

// - SYMMETRIC DIFFERENCE

// Create a function that takes two or more arrays and returns an array of the symmetric difference (△ or ⊕) of the provided arrays.

// Given two sets (for example set A = {1, 2, 3} and set B = {2, 3, 4}), the mathematical term "symmetric difference" of two sets is the set of elements which are in either of the two sets, but not in both (A △ B = C = {1, 4}). For every additional symmetric difference you take (say on a set D = {2, 3}), you should get the set with elements which are in either of the two the sets but not both (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). The resulting array must contain only unique values (no duplicates).

function sym(...args) {

	function sym2(arr1, arr2) {
		let combined = [...arr1, ...arr2];
		let removed = Array.from(new Set(combined)).sort();
		let unique = [];
		removed.forEach(elem => {
			if (!(arr1.includes(elem) && arr2.includes(elem))) {
				unique.push(elem);
			} 
		});
		return unique;
	}


	if (args.length === 2) {
		return sym2(args[0], args[1]);
	} else {
		
		let answer = args.reduce((acc, arr, i, arg) => {
			if(i > 1) {
				return acc = sym2(acc, arr);
			} else if (i === 0) {
				return acc = sym2(arr, arg[i + 1]);
			} else {
				return acc;
			}
		}, [])

		return answer;
	}
}

console.log(sym([1, 2, 3], [5, 2, 1, 4])) // should return [3, 4, 5].

console.log(sym([1, 2, 3, 3], [5, 2, 1, 4])) // should return [3, 4, 5].

console.log(sym([1, 2, 3], [5, 2, 1, 4, 5]))// should return [3, 4, 5].

console.log(sym([1, 2, 5], [2, 3, 5], [3, 4, 5]))// should return [1, 4, 5]


console.log(sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]))// should return [1, 4, 5].

console.log(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]))// should return [2, 3, 4, 6, 7].

console.log(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1]))// should return [1, 2, 4, 5, 6, 7, 8, 9].

*/

//=======================================================================================

/*

// - CASH REGISTER

// Design a cash register drawer function checkCashRegister() that accepts purchase price as the first argument (price), payment as the second argument (cash), and cash-in-drawer (cid) as the third argument.

// cid is a 2D array listing available currency.

// The checkCashRegister() function should always return an object with a status key and a change key.

// Return {status: "INSUFFICIENT_FUNDS", change: []} if cash-in-drawer is less than the change due, or if you cannot return the exact change.

// Return {status: "CLOSED", change: [...]} with cash-in-drawer as the value for the key change if it is equal to the change due.

// Otherwise, return {status: "OPEN", change: [...]}, with the change due in coins and bills, sorted in highest to lowest order, as the value of the change key.

// Penny	$0.01 (PENNY)
// Nickel	$0.05 (NICKEL)
// Dime	$0.1 (DIME)
// Quarter	$0.25 (QUARTER)
// Dollar	$1 (DOLLAR)
// Five Dollars	$5 (FIVE)
// Ten Dollars	$10 (TEN)
// Twenty Dollars	$20 (TWENTY)
// One-hundred Dollars	$100 (ONE HUNDRED)



function checkCashRegister(price, cash, cid) {

	const currencyObject = {
		PENNY: 0.01,
		NICKEL: 0.05,
		DIME: 0.1,
		QUARTER: 0.25,
		ONE: 1,
		FIVE: 5,
		TEN: 10,
		TWENTY: 20,
		"ONE HUNDRED": 100,		
	}

	function addValuesAndCoins(cid) {

		return cid.map(arr => {
			return [...arr, currencyObject[arr[0]], Math.round(arr[1] / currencyObject[arr[0]]) ]; 
			});
	}

	function calculateCashAvailable (cid) {
		if (cid) {
			return parseFloat(cid.reduce((acc, arr) => {
				return acc += arr[1];
			}, 0).toFixed(2));
			
		}
	}

	function calculateChangeArray(changeDue, cid) {

		let convertedArr = addValuesAndCoins(cid);

		let changeTobeChecked = changeDue;

		// console.log("convertedArr: ", convertedArr)

		let changeArr =  convertedArr.reverse().reduce((acc, arr) => {

			if (changeDue === 0 || changeDue < arr[2] || arr[1] === 0) {
				return acc;
			} else if (changeDue >= arr[1]) {
				changeDue = changeDue - arr[1];
				changeDue = parseFloat(changeDue.toFixed(2));
				acc.push(arr);
				return acc;
			} else if (changeDue < arr[1] && changeDue >= arr[2]) {
				let coins = Math.floor(changeDue / arr[2]);
				changeDue = changeDue - (coins * arr[2]);
				changeDue = parseFloat(changeDue.toFixed(2));
				let temp = [arr[0], coins * arr[2], arr[2], coins];
				acc.push(temp);
				return acc;
			}

		}, []);

		// console.log("ChangeArr within function", changeArr);
		
		let cashInChange = calculateCashAvailable(changeArr);

		// console.log('abc', cashInChange)

		if (cashInChange === changeTobeChecked) {
			return changeArr;
		} else {
			return false;
		}
	}

	function convertToFormat(changeArray) {
		if(changeArray) {

			return changeArray.map(arr => [arr[0], arr[1]]);
		
		}
	}

	
	let changeDue = parseFloat((cash - price).toFixed(2));			
	

	let cashInDrawer = calculateCashAvailable(cid);
	// console.log("cashInDrawer: ", cashInDrawer);
	
	// console.log("changeDue: ", changeDue);


	let changeArray = calculateChangeArray(changeDue, cid);
	// console.log("changeArray: ", changeArray);

	// console.log("Cash In Change: ", calculateCashAvailable(calculateChangeArray(changeDue, cid)));
	
	// console.log("Cash Remaining: ", calculateCashAvailable(cid) - changeDue);

	// console.log("==========================================")
	

	
	if (changeArray) {
		if (changeDue > cashInDrawer) {
			return {
				status : "INSUFFICIENT_FUNDS", 
				change: [],	
			};
		} else if (changeDue === cashInDrawer) {
			return {
				status: "CLOSED",
				change: cid,
			};
		} else {
			return {
				status: "OPEN",
				change: convertToFormat(calculateChangeArray(changeDue, cid)),
			};
		}

	} else {
		return {
				status : "INSUFFICIENT_FUNDS", 
				change: [],	
			};	
	}

}


console.log(checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]])) //should return {status: "OPEN", change: [["QUARTER", 0.5]]}

console.log(checkCashRegister(3.26, 100, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]])) //should return {status: "OPEN", change: [["TWENTY", 60], ["TEN", 20], ["FIVE", 15], ["ONE", 1], ["QUARTER", 0.5], ["DIME", 0.2], ["PENNY", 0.04]]}

console.log(checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 1], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])) //should return {status: "INSUFFICIENT_FUNDS", change: []}


console.log(checkCashRegister(19.5, 20, [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])) // should return {status: "CLOSED", change: [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]]}


*/

//============================================================================================

/*

// - TELEPHONE NUMBER VALIDATOR

function telephoneCheck(str) {
  
  let r1 = /^1?\s?\d\d\d-\d\d\d-\d\d\d\d/g; //1 555-555-5555
  let r2 = /^1?\s?\(\d\d\d\)-?\d\d\d-\d\d\d\d/g; // 1 (555)-555-5555
  let r3 = /^1?\s?\(\d\d\d\)\s\d\d\d-\d\d\d\d/g; // 1 (555) 555-5555
  let r4 = /^\d\d{8}\d$/g //5555555555
  let r5 = /1?\s?\d\d\d\s\d\d\d\s\d\d\d\d/g  // 1 555 555 5555
  return r1.test(str) || r2.test(str) || r3.test(str) || r4.test(str) || r5.test(str);
}

console.log(telephoneCheck("555-555-5555"));

console.log('true ', telephoneCheck("1 555-555-5555"))// should return true.
console.log('true ', telephoneCheck("1 (555) 555-5555"))// should return true.
console.log('true ', telephoneCheck("5555555555"))// should return true.
console.log('true ', telephoneCheck("555-555-5555"))// should return true.
console.log('true ', telephoneCheck("(555)555-5555"))// should return true.
console.log('true ', telephoneCheck("1(555)555-5555"))// should return true.
console.log('false ', telephoneCheck("555-5555"))// should return false.
console.log('false ', telephoneCheck("5555555"))// should return false.
console.log('false ', telephoneCheck("1 555)555-5555"))// should return false.
console.log('true ', telephoneCheck("1 555 555 5555"))// should return true.
console.log('true ', telephoneCheck("1 456 789 4444"))// should return true.
console.log('false ', telephoneCheck("123**&!!asdf#"))// should return false.
console.log('false ', telephoneCheck("55555555"))// should return false.
console.log('false ', telephoneCheck("(6054756961)"))// should return false
console.log('false ', telephoneCheck("2 (757) 622-7382"))// should return false.
console.log('false ', telephoneCheck("0 (757) 622-7382"))// should return false.
console.log('false ', telephoneCheck("-1 (757) 622-7382"))// should return false
console.log('false ', telephoneCheck("2 757 622-7382"))// should return false.
console.log('false ', telephoneCheck("10 (757) 622-7382"))// should return false.
console.log('false ', telephoneCheck("27576227382"))// should return false.
console.log('false ', telephoneCheck("(275)76227382"))// should return false.
console.log('false ', telephoneCheck("2(757)6227382"))// should return false.
console.log('false ', telephoneCheck("2(757)622-7382"))// should return false.
console.log('false ', telephoneCheck("555)-555-5555"))// should return false.
console.log('false ', telephoneCheck("(555-555-5555"))// should return false.
console.log('false ', telephoneCheck("(555)5(55?)-5555"))// should return false.

*/

//=============================================================================================

/*

// - PALINDROM CHECKER

function palindrome(str) {
  let temp = str.replace(/[\W_]/g, '').toLowerCase(); // to remove all non-alphaneumeric characters
  console.log(temp);
  return [...temp].reverse().join('') === temp;
}


console.log(palindrome("eye"));
console.log(palindrome("never odd or even"))// should return true.
console.log(palindrome("nope"))// should return false.
console.log(palindrome("almostomla"))// should return false.
console.log(palindrome("My age is 0, 0 si ega ym."))// should return true.
console.log(palindrome("1 eye for of 1 eye."))// should return false.
console.log(palindrome("0_0 (: /-\ :) 0-0"))// should return true.
console.log(palindrome("five|\_/|four"))// should return false.


*/

//=======================================================================================================

/*

// - MAP THE DEBRIS - Return a new array that transforms the elements' average altitude into their orbital periods (in seconds).

function orbitalPeriod(arr) {
  const GM = 398600.4418; //  units km3s-2
  const earthRadius = 6367.4447; // km

  //avgAlt is also in km

  return arr.map(obj => {
    let a = earthRadius + obj.avgAlt;
    let orbitalPeriod = Math.round(2 * Math.PI * Math.sqrt(Math.pow(a, 3) / GM));
    return {
      name: obj.name,
      orbitalPeriod,
    }
  });
  
}

console.log(orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}])); // returns [{name: "sputnik", orbitalPeriod: 86400}]

console.log(orbitalPeriod([{name: "iss", avgAlt: 413.6}, {name: "hubble", avgAlt: 556.7}, {name: "moon", avgAlt: 378632.553}])) // should return [{name : "iss", orbitalPeriod: 5557}, {name: "hubble", orbitalPeriod: 5734}, {name: "moon", orbitalPeriod: 2377399}]


*/

//===============================================================================================================

/*


// Make a Person - Fill in the Object contructor with the following methods

// getFirstName() 
// getLastName()
// getFullName()
// setFirstName(first)
// setLastName(last)
// setFullName(firstAndLast)

var Person = function(firstAndLast) {
  // Complete the method below and implement the others similarl


    let fullName = firstAndLast;

    this.getFullName = function() {
      return fullName;
    };
  
    this.getFirstName = function() {
      return this.getFullName().split(' ')[0];
    };
  
    this.getLastName = function() {
      return this.getFullName().split(' ')[1];
    };
  
    this.setFirstName = function(first) {
      fullName = first + ' ' + this.getLastName();
    };
  
    this.setLastName = function(last) {
      fullName = this.getFirstName() + ' ' + last;
    };
  
    this.setFullName = function(firstAndLast) {
      fullName = firstAndLast;
    };
    
  }

var bob = new Person('Bob Ross');
console.log(bob.getFullName());

console.log(Object.keys(bob))// should return 6.
console.log(bob instanceof Person)// should return true.
console.log(bob.firstName)// should return undefined.
console.log(bob.lastName)// should return undefined.
console.log(bob.getFirstName())// should return "Bob".
console.log(bob.getLastName()) //should return "Ross".
console.log(bob.getFullName()) //should return "Bob Ross".

bob.setFirstName("Haskell")
console.log(bob.getFullName())// should return "Haskell Ross" after bob.setFirstName("Haskell").

bob.setLastName("Curry")
console.log(bob.getFullName())// should return "Haskell Curry" after bob.setLastName("Curry").

bob.setFullName("Haskell Curry")
console.log(bob.getFullName())// should return "Haskell Curry" after bob.setFullName("Haskell Curry").

bob.setFullName("Haskell Curry")
console.log(bob.getFirstName())// should return "Haskell" after bob.setFullName("Haskell Curry").

bob.setFullName("Haskell Curry")
console.log(bob.getLastName())// should return "Curry" after bob.setFullName("Haskell Curry").

*/

//==========================================================================================

/*

// Create a function that sums two arguments together. If only one argument is provided, then return a function that expects one argument and returns the sum.


function addTogether(x, y) {
  if(typeof x !== 'number') {
    return undefined;
  } else if(!y) {
    return function(newY) {
      if(typeof newY !== 'number') {
        return undefined;
      } else {
        return x + newY;
      }
    }
  } else {
    if(typeof y !== 'number') {
      return undefined;
    } else {
      return x + y;
    }
  }
}
  	
console.log(addTogether(2, 3)); // should return 5.
console.log(addTogether(2)(3)) // should return 5.
console.log(addTogether("http://bit.ly/IqT6zt")) //should return undefined.
console.log(addTogether(2, "3")); //should return undefined.
console.log(addTogether(2)([3])); //should return undefined


*/

//==============================================================================

/*

// checks if pre is truthy on all elements (objects) of the collection array

function truthCheck(collection, pre) {
  // Is everyone being true?
  return collection.every(obj => {
  	return !!obj[pre];
  });
}

console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex")); // returns true

console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex")) //should return false.

console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male", "age": 0}, {"user": "Dipsy", "sex": "male", "age": 3}, {"user": "Laa-Laa", "sex": "female", "age": 5}, {"user": "Po", "sex": "female", "age": 4}], "age")) // should return false.

console.log(truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true}, {"name": "FastFoward", "onBoat": null}], "onBoat")) // should return false

console.log(truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true, "alias": "Repete"}, {"name": "FastFoward", "onBoat": true}], "onBoat")) // should return true

console.log(truthCheck([{"single": "yes"}], "single")) //should return true

console.log(truthCheck([{"single": ""}, {"single": "double"}], "single")) //should return false

console.log(truthCheck([{"single": "double"}, {"single": undefined}], "single")) // should return false

console.log(truthCheck([{"single": "double"}, {"single": NaN}], "single")) // should return false

*/

//===================================================================================
 
/*

// Return an English translated sentence of the passed binary str

function binaryAgent(str) {
  return str
  			.split(' ')
  			.map(binary => {
  				return String.fromCharCode(parseInt(binary, 2));
  			})
  			.join('');
}

console.log(binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"));  // returns "Aren't bonfires fun!?"

*/

//==========================================================================================

/*


// Flatten array - any depth

function steamrollArray(arr) {
  // I'm a steamroller, baby
  return arr.reduce( (acc, val) => Array.isArray(val) ? acc.concat(steamrollArray(val)) : acc.concat(val), []);
}

console.log(steamrollArray([1, [2], [3, [[4]]]]));

*/

//============================================================================================

/*

// Keep dropping elements will the position func(element) returns true, return the remaining array from that point onwards, else return [];

function dropElements(arr, func) {
  // Drop them elements.
  for(let elem of arr) {
    if(func(elem)) {
      return arr.slice(arr.indexOf(elem), );
    }
  }

  return [];

}

console.log(dropElements([1, 2, 3, 4], function(n) {return n >= 3;})); //should return [3, 4].
console.log(dropElements([0, 1, 0, 1], function(n) {return n === 1;}));// should return [1, 0, 1].
console.log(dropElements([1, 2, 3], function(n) {return n > 0;}));// should return [1, 2, 3].
console.log(dropElements([1, 2, 3, 4], function(n) {return n > 5;})); //should return [].
console.log(dropElements([1, 2, 3, 7, 4], function(n) {return n > 3;})); //should return [7, 4].
console.log(dropElements([1, 2, 3, 9, 2], function(n) {return n > 2;})); // should return [3, 9, 2].



*/

//===========================================================================================

/*


// *** FIND THE LCM of all the numbers between the given numbers (inclusive)

function smallestCommons(arr) {

  let arrLarge = arr[0] > arr[1]? arr[0]: arr[1];
  let arrSmall = arr[0] < arr[1]? arr[0]: arr[1];

  if(arrSmall === 1) {
  	arrSmall += 1;
  }

  // console.log('arrSmall: ', arrSmall);
  // console.log('arrLarge: ', arrLarge);


  let populateArr = [];   

  for(let i = arrSmall; i <= arrLarge; i++) {
  	populateArr.push(i);
  }

  function generatePrimes(num) {
  	let arr = [];
  	let primes = [];
  	for(let i = 2, j = 2; i <= num; i++, j++) {
  		arr.push(i);
  		primes.push(j);
  	}
  	arr.forEach(num => {
  		primes = primes.filter(number => !(Number.isInteger(number / num) && Math.round(number / num >= 2)));  //Using Sieve method to generate primes upto and including num
  	})

  	return primes;
	}


  let primes = generatePrimes(arrLarge);

  // Calculating prime factors in Obj form of each number in populateArr

 	let primeFactors = populateArr.map(num => {
 		let factors = {};
 		primes.forEach(prime => {
 			while(Number.isInteger(num / prime) && num !== 1) {
 				num /= prime;
 				if(factors[prime]) {
 					factors[prime] += 1;	
 				} else {
 					factors[prime] = 1;	
 				}
 				
 			}
 		})

 		return factors;
 		}
 	);

 	
 	// Reducing the prime factors obj to obtain only the highest power of each prime factor

 	let primeFactorsReduced = primeFactors.reduce( (acc, obj) => {
 		for(let [key, value] of Object.entries(obj)) {
 			if(acc[key]) {
 				if(obj[key] > acc[key]) {
 					acc[key] = value;
 				}
 			} else {
 				acc[key] = value;
 			}
 		}
 		return acc;
 	}, {})

 	
 	// calculating sum product of each prime factor and its power in the prime factor reduced obj

 	let answer = 1;

 	for(let [key, value] of Object.entries(primeFactorsReduced)) {
 		console.log('[key, value]: ', key, value)
 		answer *= Math.pow(Number(key), value);
 	}

 	return answer;
}

	

console.log(smallestCommons([1,5]));   //returns 60

console.log(smallestCommons([2, 10]));     // should return 2520.
console.log(smallestCommons([1, 13]));   // should return 360360.
console.log(smallestCommons([23, 18]));    // should return 6056820.

*/

// =======================================================================================

/*


// SUM of all PRIMES up to num

function sumPrimes(num) {
  
  let arr = [];
  let primes = [];

  // debugger;

  for(let i = 2, j = 2; i <= num; i++, j++) {
  	arr.push(i);
  	primes.push(j);
  }

  arr.forEach(num => {
  	primes = primes.filter(number => !(Number.isInteger(number / num) && Math.round(number / num >= 2)));  //Using Sieve method to generate primes
  })


  return primes.reduce((a, x) => a + x, 0);


}

console.log(sumPrimes(10));  //return 17

console.log(sumPrimes(977)); //should return 73156.

*/


//=====================================================================================

/*


// SUM OF All ODD FIBONACCI NUMBERS <= num

function sumFibs(num) {
  let fib = [1, 1];
  let newEntry = 0;

  // debugger;

	while(true) {

		newEntry = fib[fib.length - 1] + fib[fib.length - 2];
		if(newEntry <= num) {
			fib.push(newEntry);
		} else {
			break;
		}
	}

  return fib
  				.filter(num => num % 2 !== 0)
  				.reduce((a, x) => a + x, 0);

}

console.log(sumFibs(4));  //returns 5
console.log(sumFibs(4000000)); //should return 4613732.

*/


// ================================================================================================

/*

function convertHTML(str) {
  // &colon;&rpar;

  // & => &amp;
  // < => &lt;
  // > => &gt;
  //"" => &quot;
  //' => &apos;


  return str
  				.replace(/&/g, '&amp;')
  				.replace(/</g, '&lt;')
  				.replace(/>/g, '&gt;')
  				.replace(/"/g, '&quot;')
  				.replace(/'/g, '&apos;');
}

console.log(convertHTML("Dolce & Gabbana"));
console.log(convertHTML("Hamburgers < Pizza < Tacos"));
console.log(convertHTML("Sixty > twelve"));
console.log(convertHTML('Stuff in "quotation marks"'));
console.log(convertHTML("Schindler's List"));

*/

//===============================================================================================

/*

// SORTED UNION - join the array keeping only unique items and maintaining order

function uniteUnique(...arrs) {

  let temp = new Set;
  for(let subArr of arrs) {
  	subArr.forEach(elem => {
  		temp.add(elem);
  	})
  }

  console.log([...temp]);
}
uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);

*/

//==============================================================================================

/*


// FIND THE MISSING LETTERS


function fearNotLetter(str) {
	let temp = [...str];
  for(let i = 1; i < temp.length; i++) {

  	if(temp[i].charCodeAt(0) - temp[i - 1].charCodeAt(0) !== 1) {
  		return String.fromCharCode((temp[i].charCodeAt(0) - 1));
  	}
  }
}

console.log(fearNotLetter("abce")); //returns 'd'

console.log(fearNotLetter("abcdefghijklmnopqrstuvwxyz"));  //returns undefined



*/


//================================================================================================

/*

//  DNA PAIRING - Base pairs are a pair of AT and CG. Match the missing element to the provided character.

// Return the provided character as the first element in each array.

// For example, for the input GCG, return [["G", "C"], ["C","G"],["G", "C"]]

function pairElement(str) {
  let temp = [...str];
  temp = temp.map(letter => {
  	if(letter === 'G') {
  		return ['G', 'C']
  	} else if (letter === 'C') {
  		return ['C', 'G'];
  	} else if (letter === 'A') {
  		return ['A', 'T'];
  	} else {
  		return ['T', 'A'];
  	}
  })
  return temp;
}

pairElement("GCG");


*/


//==================================================================================================

/*

function myReplace(str, before, after) {
  let temp = str.split(' ');

  return temp
  				.map(word => {
  					if(word === before) {
  						if(before[0] === before[0].toUpperCase()) {  // if the first letter of before is capital
  							let [first, ...rest] = [...after];
  							after = first.toUpperCase() + rest.join('');  //converting first letter of after to capital as well
  							return after;
  						} else {
  							return after;
  						}
  					} else {
  						return word;
  					}
  				})
  				.join(' ');
}

console.log(myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped")); //returns jumped replaced by leaped


console.log(myReplace("He is Sleeping on the couch", "Sleeping", "sitting")); //returns Sleeping replaced by Sitting

*/

//=============================================================================================

/* 


// PIG LATIN

function translatePigLatin(str) {
	if(/^[aeiou]/.test(str)) {
		return str + 'way';
	}

  let consonants = [...str];
  let i = 0;
  let init = '';
  while(!/[aeiou]/.test(consonants[i])) {
  	init += consonants[i];
  	i++;
  }

  for(let elem of init) {
  	consonants.shift();
  }

  return consonants.join('') + init + 'ay';

}

console.log(translatePigLatin("california")); // should return "aliforniacay"

console.log(translatePigLatin("algorithm")); //should return "algorithmway".

*/






//============================================================================================================================================


/*

// SPINAL TAP CASE - FCC

function spinalCase(str) {
	let prop = str.replace(/([A-Z])/g, ' $1');  //splits camelCase and adds space before capital letter
	prop = prop.split(/[\s\-_]/g);              // splits the string by 'space', '-' and/or '_'
	return prop
			.filter(word => word)               // removes empty strings that may have been created in above steps 
			.map(word => word.toLowerCase())    
			.join('-');
	// console.log(prop);
}


console.log(spinalCase("thisIsSpinalTap"));
console.log(spinalCase("AllThe-small Things"));



*/


// ==================================================================================

/* 

//  Wherefore art thou - FCC

function whatIsInAName(collection, source) {
  // What's in a name?
  let arr = [];

  let source_entries = Object.entries(source);    // get the array of [key,value] pairs of source

  arr = collection.filter( obj => {
  	for(let [key, value] of source_entries) {
  		if( !Object.keys(obj).includes(key) || !Object.values(obj).includes(value)) {   // if in any obj, source key or source value is missing,
  			return false;																																	// it is removed
  		}
  	}
  	return true;
  });
  return arr;
}

console.log(whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 }));





*/

//=============================================================================================

/*

//  URL SLUG - FCC

// the global variable
var globalTitle = " Winter Is  Coming";

// Add your code below this line
function urlSlug(title) {
  let arr = title.split(/[\s]+/);
  // console.log(arr);
  arr = arr
  		.filter(word => word)
  		.map(word => word.toLowerCase());
  return arr.join('-');
  
}
// Add your code above this line

console.log(urlSlug(globalTitle)); // Should be "winter-is-coming"




*/




	</script>
</body>
</html>